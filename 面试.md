熟悉微前端框架 single-spa qiankun wujie,对微前端框架原理有一定深入理解，阅读过 single-spa、qiankun、wujie 源码
微前端解决的问题 1.不同的团队(技术栈不同)，同时开发一个应用 2.每个团队开发的模块都可以独立开发，独立部署 3.实现增量迁移

如何实现微前端？
可以将一个应用划分成若干个子应用，将子应用打包成一个个的模块。当路径切换时加载不同的子应用。这样每个子应用都是独立的，技术栈可不用做限制了。
1.iframe
1.1 微前端的最简单方案，通过 iframe 加载子应用
1.1 通信可以通过 postMessage 进行通信
1.2 完美的沙箱机制自带应用隔离

2.web Components
2.1 将前端应用程序分解为自定义的 HTML 元素
2.2 基于 CustomEvent 实现通信
2.3 Shadow Dom 天生的作用域隔离

3.single-spa (SystemJs)
3.1 通过路由劫持实现应用的加载（采用 SystemJs）,提供应用间公共组件加载以及公共业务逻辑的处理，子应用需要暴露固定的钩子 bootstrap mount unmount 接入协议
3.2 基于 prop 主子应用间通信
3.3 无沙箱机制，需要自己实现 js 沙箱以及 css 沙箱

4.Module federation
4.1 通过模块联邦将组件进行打包导出使用
4.2 共享模块的方式进行通信
4.3 无 css 沙箱和 JS 沙箱

SystemJs 是一种规范，与 commonjs umd 一样
//1.通过 jsonP 加载第三方库(如 React、ReactDom)，第三方库必须是 umd 格式，
UMD（Universal Module Definition，通用模块定义）是一种模块化编程模式，旨在编写可以在浏览器、Node.js 和其他模块加载器（如 AMD）中都能正常工作的 JavaScript 代码。使用 UMD，可以确保同一个脚本在不同的环境中都能正常运行，而不需要修改。
//2.jsonP 加载入口文件 index.js
//3.执行 System.register 保存 deps, declare(函数) => 返回值是一个 setter（webpack 需要的变量），execute(具体的渲染函数)
//4.遍历 deps，并且使用 jsonP 加载依赖项，从 Window 获取如 react、reactDom 传入到 setter，最后再执行 execute
// 本质就是先加载依赖列表，再去加载逻辑
//（内部通过 script 加载资源，给 window 拍照保存先后状态）

single-spa
// 微前端就是可以加载不同的应用，single-spa 是基于路由的微前端
// 如何接入已经写好的应用，对于 single-spa 而言我们需要改写子应用（接入协议：bootstrap, mount, unmount）
